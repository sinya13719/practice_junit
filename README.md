# JUnit 実践入門
下記には書籍「JUnit実践入門」の各章の要約を記載します。  
[参照書籍：JUnit実践入門](https://gihyo.jp/book/2012/978-4-7741-5377-3)
<dl>
  <dt>テスト対象のプログラム</dt>
    <dd>practice_junit/Turial-JUnit/src/</dd>
  <dt>テストクラス</dt>
    <dd>practice_junit/Turial-JUnit/test/</dd>
</dl>
  
## 【１章：JUnitチュートリアル】  
### 環境構築  
- Javaプロジェクトの作成  
- テスト対象クラスの作成  
- テストクラスの作成  
### テストコードの記述  
### テスト実行  
  
  
## 【２章：ユニットテストは何のためにテストするのか】
### ソフトウェアテストの3つの特徴
- 事前条件（テストデータ、環境など）による制約がある
- 実際のソフトウェアのふるまいを記録する
- 期待される結果との検証
### テスト技法  
- ホワイト・ブラックボックステスト  
- 同値クラスに対するテスト：ソフトウェアが同様の結果をもたらす値を同値クラスとしてグループ化し、グループが膨大である場合、代表値を選び、テストを行う
### ユニットテストの持つべき特徴
<table>
  <thead>
    <tr>
      <th>特徴</th> <th>詳細</th>
    </tr>
  </thead>
  <tr>
    <td>自動化されたテスト</td> <td>何度でも繰り返してテストを実行できることで、不具合の早期発見や安心してリファクタリングが行えるようになります.</td>
    </tr>
  <tr>
    <td>結果が一定であること</td> <td>理想的には、すべてのテストが成功している状態を維持することが望ましいです。<br>
                                    成功しないテストを放置する状況や実行ごとに成功するかが変わる状態は好ましくありません。</td>
  </tr>
  <tr>
    <td>仕様書として読めること</td> <td>仕様書を別途作成すると、認識相違がどうしても発生してしまうが、プログラムであれば認識相違が発生しにくい</td>
  <tr>
    <td>テスト対象</td> <td>そのテストの対象（クラスやオブジェクト）</td>
  </tr>
</table>
  
  
## 【３章：テスティングフレームワーク】
### JUnitによるユニットテストの記法
- `public`メソッドとする
- `org.junit.Test`アノテーションを付与する
- 戻り値を`void`とし、引数を持たない
### 可読性の高いテストコードを書くための基礎となる用語
<table>
  <thead>
    <tr>
      <th>用語</th> <th>説明</th>
    </tr>
  </thead>
  <tr>
    <td>テストケース</td> 
    <td>
      ある状況である入力をしたときにどのような結果を期待できるのかを記述したもの。<br>
      ユニットテストに限らず、ソフトウェアのテストでは次の３点が重要です。<br>
        ・テストを行う前提条件<br>
        ・テストに用いる入力値や操作<br>
        ・テストを行ったときに期待される値や操作
    </td>
  </tr>
  <tr>
    <td>テスト対象</td> <td>そのテストの対象（クラスやオブジェクト）</td>
  </tr>
  <tr>
    <td>メソッドと副作用</td> 
    <td>わかりにくいテストコードになってしまう最大の要因は、テスト対象がテストしにくい設計になっていることです<br>
        そして次のような性質を持っているメソッドはテストが行いやすいメソッドです。<br>
        ・メソッドが戻り値を持つ<br>
        ・メソッドの呼び出しの結果、副作用がない<br>
        ※副作用とはオブジェクトの内部状態（インスタンス変数など）が変更されないことである<br>
        ・同じ状態、同じパラメータで実行すれば、必ず同じ結果を返す
    </td>
  </tr>
  <tr>
    <td>４フェーズテスト</td>
    <td>ユニットテストにかかわらず、ソフトウェアのテストは次の４つのフェーズで実行されます<br>
      １．事前処理：テスト対象オブジェクトの初期化、必要な入力値、期待される結果などの準備<br>
      ２．実行テスト：対象オブジェクトに対し、テストする操作を一つだけ行います<br>
      ３．検証：テストの結果として得られた実測値が期待値と等価であるかを検証する<br>
      ４．後処理：次のテストの実行に影響がないように後処理をする
    </td>
  </tr>
  <tr>
    <td>テストフィクスチャ</td> <td>ー</td>
  </tr>
</table>

### JUnitのテストパターン
- 標準的なふるまいを検証するテスト（**正常系**）
- 例外の創出を検証するテスト（**異常系**）
- コンストラクタを検証するテスト（特殊なパターンですがインスタンスが生成されたときに、初期状態として妥当な値が設定されているかを確認します）
  
  
## 【４章：アサーション】
### アサーションメソッド
- Matcher APIで提供されているアサーションメソッド
- その他で提供されているアサーションメソッド 
### Matcher APIで提供されている様々なメソッド
### カスタムMatcherの作成手順


## 【５章：テストランナー】
### コマンドラインからのJUnitの実行
JUnitによるユニットテストをコマンドラインから実行するには、`junit.runner.JUnitCore`を使用します。

#### JUnitCoreクラスの仕組み
`JUnitCore`クラスの`main`メソッドが実行されると、`JUnitCore`クラスの起動引数で指定したテストクラスから<br>
Test<アノテーションの付いたメソッド（テストケース）を収集します<br>
**まとめると、`JUnitCore`クラスは以下の流れで動きます**
1. テストケースの収集
2. テストの実行
3. テスト結果の出力

### テストランナーとは？
ソフトウェア開発では、テストクラス単位でテストを実行するだけでは不十分で、プロジェクトの全テストケースの実行、特定のテストケースに絞った実行、<br>
特定のテストケースを除外した実行などのカスタマイズ性が求められます。<br>
そのためJUnitでは**テストランナー**という仕組みを提供しています

#### JUnitが提供するテストランナー
- Suite
  - 複数のテストクラスをまとめて実行する
  - テストスイートクラスでは、ほかのテストスイートクラスを指定することが出来ます。<br>
    パッケージごとにパッケージ内の全テストクラスを含むAllTestsを作成し、それらのテストスイートクラスをすべて含む<br>
    テストスイートクラスを作成することで、プロジェクト内の全テストケースを実行するテストスイートを作成できます。
- Enclosed
  - 構造化したテストクラスを実行する
  - Enclosedクラスをテストランナーとして指定した場合、ネストしたクラスを定義し、テストケースは各ネストしたクラスに定義します。
- Theories
  - パラメータ化したテストケースを実行する
  - パラメータ化テストとは、テストケースとテストデータを分離し、同じテストメソッドを複数のパラメータで再利用して使います。
- Categories
  - 特定カテゴリのテストクラスをまとめて実行する
  - テストケースをカテゴリー化し、実行するテストケースをフィルタリングする
    可能であれば、すべてのテストケースを実行すべきです。ですが、テスト数が増えてくると実行時間がかかりすぎてしまい、
    現実的ではないので、各テストケースにカテゴリを設定し、分割して実行します。
  
   
## 【６章：テストのコンテキスト】
### テストケースの整理方法
テストクラスに定義されたテストケースが増加してくると、テストコード自体が長く読みにくいものとなります。<br>
そしてテストコードは似たようなコードが多いため、重複が多くなりがちです。<br>
そのため重複を取り除きすぎると各テストケースの意図が不明瞭になります。<br>
なので<strong>各テストケースの独立性を保ちつつ、テストコードが読みやすく整理する必要があります。</strong><br>
以下に整理方法の代表例を記載します。

<dl>
  <dt>テストクラスの構造化</dt>
    <dd>
      一般的に、クラスベースのプログラミング言語のユニットテストでは、テスト対象となるクラスごとに対応するテストクラスを作成します。<br>
      Javaではテストクラスを慣習として</strong>「テスト対象+Test」</strong>と記述します。<br>
      多くのテストケースが定義されたテストコードの可読性が低い理由は、すべてのテストメソッドを同列に定義しているからです。<br>
      なので、<strong>テストケースが増えてきたならば、何らかの基準でグループ化し、テストクラスを構造化することが必要です。</strong>
    </dd>  
  <dt>テストケースをグループ化する</dt>
    <dd>
      テストケースをグループ化する方針としては、大きく次の二つがあります。<br>
      <strong>1. の方針は初期化処理の共通化が出来ないので、好ましくありません。2. の方針を推奨します</strong><br>
      1. テストケースで検証する操作（メソッド単位）でグループ化する<br>
      2. テストケースを共通の初期化処理を含むものでグループ化する
    </dd>
  <dt>Enclosedによるテストクラスの構造化</dt>
    <dd>
      多くあるテストケースを複数のテストクラスに分割して、整理する方法は、テストクラスの命名規則の観点であまりよろしくありません<br>
      この問題を解決するためのEnclosedによるテストクラスの構造化が使えます。<br>
      Enclosedテストランナーを利用すれば、初期化処理が共通しているテストケースをネストした複数のクラスにまとめることが出来ます。<br>
      この場合、外側のテストクラスは命名規則に従い、<strong>「テスト対象クラス名+Test」</strong>とします。<br>
      内側のそして初期化処理によってグループ化したテストクラスに関しては、<strong>「初期化状態の場合」</strong>などの初期化状態を説明するクラス名にするとよいでしょう。
    </dd>
</dl>
     
### コンテキストのパターン

<dl>
  <dt>共通のデータに着目する</dt>
    <dd>
      わかりやすい例として、データベース接続を行うクラスのユニットテストをあげます。<br>
      データベース接続を行うクラスのユニットテストでは、テストの実行前にデータベースを特定の状態に設定する必要があります<br>
      例えば、「あるテーブルが空の場合」、「10件のデータがある場合」などです。
      そのような特定の条件によってテストケースをグループ化するとよいでしょう。
    </dd>  
  <dt>共通の状態に着目する</dt>
    <dd>
      テスト対象クラスが状態を持つ場合、事前処理として行われるテスト対象オブジェクトへの操作が重要です。<br>
      事前処理の操作の結果、特定の状態となります。その状態によってテストケースをグループ化するパターンも有効です
    </dd>
  <dt>コンストラクタのテストを分ける</dt>
</dl>

### テストクラスを横断する共通処理
Enclosedテストランナーによるテストクラスの構造化を行うことで、テストクラス内の共通化処理をきれいに整理できます。<br>
しかし異なるテストクラス間で共通した処理は整理できません。このようなときは共通処理を定義した基底クラスを作成して、<br>
継承させることが多いでしょう。ですが継承はなるべく避けるべきです、なぜならば安易な継承は影響範囲の特定を困難にする恐れがあるからです。<br>
JUnitが提供する異なるテストクラス間の共通処理を抽出する機能をルールを使用すると、適切に抽出できます。


## 【７章：テストフィクスチャ】
### テストフィクスチャとは？
ソフトウェアテストでは、テスト対象となるシステムやオブジェクトだけでは成立しません。<br>
入力するデータ、テスト実行のための予備捜査、データベースなどの外部リソース、検証に必要なデータなどが必要不可欠です。<br>
これらのテストで扱うデータやテスト実行環境、オブジェクトの状態などを**フィクスチャ**と呼びます。

#### ユニットテストのフィクスチャ
- テスト対象オブジェクト
- テストの実行に必要なオブジェクト（入力値）
- テストの検証に必要なオブジェクト（検証値）
- テスト実行までに必要なテストオブジェクトの操作
- ファイルなどの外部リソース
- データベースやソケットサーバーなどの外部システム
- 依存クラスや依存外部システムのモックオブジェクト  
**多くの入力値を持ち、外部リソースにも依存するテスト対象クラスでは、特に注意してフィクスチャのセットアップを行う必要があります。**

#### フレッシュフィクスチャ
ユニットテストでは、**「フィクスチャはテストケースごとに独立し、テストの実行ごとに初期化され、終了時に解放する」**が基本です。  
この戦略は**フレッシュフィクスチャ**呼ばれます。もしフィクスチャがいくつかのテストケースごと共有されていると、<br>
テストケースの実行順序などによってフィクスチャの状態が影響を受けるかもしれません。またユニットテストを並列に実行した場合、<br>
共有されたフィクスチャが同時に複数のテストから利用されるため、あやまった入力値がテストケースに入力される恐れがあります。<br>
**Unitではテストの実行時にテストケースごとにテストクラスのインスタンスを作成し、テストメソッドを実行します。**  
**このため、テストクラスのインスタンス変数やローカル変数に保持されたテストデータは、各テストの終了時にガベージコレクタによって廃棄されます。**

#### フィクスチャとスローテスト問題
フレッシュフィクスチャは基本的なフィクスチャのセットアップパターンです。  
しかしながら、データベースを扱うテストなどでは、フィクスチャのセットアップに長い時間を要します。このような問題を**スローテスト問題**といいます。  
原因は、フィクスチャのセットアップごとに対象となるテーブルの全レコードを削除し、必要なレコードを追加するからです。  
スローテスト問題を解決するには、**テストの並列実行、共有フィクスチャ、カテゴリ化テスト**などが有効です。  
<dl>
  <dt>テストの並列実行</dt>
    <dd>マルチスレッドや複数のテスト環境で並列にテストを実行する</dd>
  <dt>共有フィクスチャ</dt>
    <dd>各テストケースで使用するフィクスチャを共有し、再利用することで、セットアップコストを抑えます</dd>
</dl>

### フィクスチャのセットアップパターン
<dl>
  <dt>インラインセットアップ</dt>
    <dd>テストメソッドごとにフィクスチャのセットアップを行います。メソッドが長くなる場合は可読性が悪くなり、何の検証を行て散るのかがわかりにくくなる。</dd>
  <dt>暗黙的セットアップ</dt>
    <dd>
      テストクラスで共通した初期化処理を、<strong>Beforeアノテーション</strong>が付加されたメソッドに抽出できます。<br>  
      そのメソッドを<strong>セットアップメソッド</strong>と呼び、各テストメソッドを実行する前に暗黙的に実行されます。<br>  
      暗黙セットアップは、Enclosedテストランナーを利用したユニットテストと相性がいいです。なぜなら共通の初期化処理を持つテストケースでグループ化するので、<br>      
      <strong>各ネスト下したクラスで、フィクスチャのセットアップのコードがセットアップメソッドに抽出され、セットアップとテストを切り分けられます。</strong>
    </dd>
  <dt>生成メソッドでのセットアップ</dt>
    <dd>
      複数のテストクラスでセットアップメソッドで共通の初期化処理を行いたい場合に使用します。<br>  
      この方法では共通した初期化処理を独立したクラスのメソッドに抽出する手法を用います。<br>
      このようにフィクスチャの生成メソッドを抽出し、フィクスチャのセットアップを行うパターンを<strong>生成メソッド</strong>と呼びます。
    </dd>
  <dt>外部リソースからのセットアップ</dt>
    <dd>
      Javaではフィクスチャのセットアップのようなデータを生成するコードはあまり読みやすくありません。<br>    
      なので外部に定義したリソースファイルにテストデータを記述し、生成メソッドなどで読み込む手法が有効です。<br>    
      リソースファイルには、YAML・XML・JSON・CSVなどがあります。  
    </dd>
</dl>


## 【８章：パラメータ化テスト】
### テストデータの選択
テストデータをどのように選択するかは、ソフトウェアテストにおいて重要な要素の一つです。なぜなら入力可能な値をすべて検証することは不可能なので  
効率よく検証できるデータを選択するしかないからです。
#### どのくらいのテストデータが必要か？
<dl>
  <dt>同値クラスによるテストデータの選択</dt>
    <dd>
      同値クラスとは、テスト対象メソッドで同じ結果を返す入力値の集合です。<br>
    </dd>
  <dt>組み合わせによるテストデータの選択</dt>
    <dd>
      各項目に対する条件分岐が存在する際に、その境界付近のテストデータ
    </dd>  
    </dd>
</dl>

### 入力値と期待値のパラメータ化
<table>
  <thead>
    <tr>
      <th>テストランナーやアノテーションの種類</th> <th>役割</th>
    </tr>
  </thead>
  <tr>
    <td>Theories（テストランナー）</td> <td>パラメータ化テストを行うクラスに付ける</td>
  </tr>
  <tr>
    <td>@Theory</td> <td>パラーメタ化テストを行うメソッドに付ける</td>
  </tr>
  <tr>
    <td>@DataPoint</td> <td>一つのテストメソッドに対して、一つのパラメータを定義する</td>
  </tr>
  <tr>
    <td>@DataPoints</td> <td>一つのテストメソッドに対して、複数のパラメータを定義する</td>
  </tr>
</table>

### 組み合わせテスト
#### Assumeによるパラメータのフィルタリング
AssumeTrueメソッドやAssumeThatメソッドを使って、特定の条件に合致するパラメータだけを検証することが出来ます。

### パラメータ化テストの問題
#### データの網羅性
テスト技法を意識しないで適当なパラメータを設定した場合、網羅性が欠如したテストになってしまう
#### パラメータに関する情報の欠如
テスト失敗時にテストメソッドに入力したパラメータの情報まで報告されないので、あるテストメソッドが失敗したのはわかるが、  
どんなパラメータを入力して、失敗したのかまではわからないので、問題の分析に時間がかかってしまいます。


## 【９章：ルール】
### ルールとは？
<strong>JUnitでは何をテストするのか（テストケース）とどう実行するのか（テストランナー）が分離されています。</strong>  
独自のテストランナーを作ることで、ユニットテストの実行をカスタマイズすることが出来ます。  
しかしながら独自のテストランナーを作るのには手間がかかります。なのでJUnitでは、プラグインのようにユニットテストを拡張できる機能が搭載されています。  
その機能を**ルール**と言います。

### ルールの仕組み
- Beforeアノテーションと同様に、テストクラスごとに拡張処理を行うことが出来る。  
- 複数ルールを宣言するとき、ルールの実行制御を行いたい場合は、RuleChainを使用します。
- ルールには単体で利用できるものとカスタムルールを作るときに基底クラスとして利用するルールの二種類があります。

### ルールの種類
<table>
  <thead>
    <tr>
      <th>ルール</th> <th>説明</th>
    </tr>
  </thead>
  <tr>
    <td>TemporaryFolder</td> <td>TemporaryFolderクラスはテストの独立性を高めるため、テストケースごとに独立して一時フォルダを作成・削除を行います。<br>
                                 ルールの拡張を行う際には<strong>TemporaryFolderを継承したサブクラスを作成し、
                                 一時フォルダの作成を行うbeforeメソッドのオーバーライドを行います。その際に親クラスのbeforeメソッドをか必ず呼び出す。</strong></td>　　　　　　　　
  </tr>
  <tr>
    <td>ExternalResource</td> <td>ExternalResourceクラスは抽象クラスであり、具体的に管理するリソースはサブクラスで定義します。<br>
                                  データベース、ソケット、組み込みサーバなどを扱うテストで重宝します。<br>
                                  ExternalResourceクラスはbeforeメソッドで外部リソースの初期化処理を定義し、<br>
                                  afterメソッドで外部リソースの解放処理を定義します。</td>
  </tr>
  <tr>
    <td>Vertify</td> <td>Vertifyクラスはテスト事後条件を検証します。ExternalResourceクラスと同様に抽象クラスです</td>
  <tr>
    <td>ErrorCollector</td> <td>ErrorCollectorクラスはアサーションの失敗やエラーが発生した場合でも、テストを継続して実行することのできる<br>
                                仕組みを提供します。テストが失敗したという情報は、ErrorCollectorオブジェクトに蓄積され、<br>
                                テストが失敗によって中断されず、すべての項目に関する情報を知ることが出来ます。</td>
  </tr>
  <tr>
    <td>ExceptedException</td> <td>送出された例外を詳細に検証するためのルールです。</td>
  </tr>
  <tr>
    <td>Timeout</td> <td>テストケースのタイムアウトを設定するためのルールです。<br>
                         テストクラス内のすべてのテストメソッドにタイムアウトが設定されます。</td>
  </tr>
  <tr>
    <td>TestWatcher</td> <td>テスト実行時の様々なタイミングで追加の処理を実行できます。<br>
                             TestWatcherクラスは抽象クラスであり、サブクラスで必要あメソッドをオーバーライドして利用します。<br>
                             よく使われる例が、各フェーズでログを出力する場合です。</td>
  </tr>
  <tr>
    <td>TestName</td> <td>テストメソッド内で実行中のテストメソッド名を取得するためのルールです。<br>
                          TestNameオブジェクトからテストメソッド名を取得します。<br>
                          JUnitにおけるテストメソッド名はテストケースの概要を表しているので、有益な情報となるのでこのルールは重宝されます。</td>
  </tr>
</table>

### RuleChainによるルールの連鎖
ルールをテストクラスに定義するだけでは、順序の制御を行うことが出来ないので、`RuleChain`クラスにてルールをchainさせて記述し、実行順序の制御を行います。


## 【１０章：カテゴリ化テスト】
### スローテスト問題の対策
#### テストの実行時間を短くするための方法
- テストデータの共有化
- リアルオブジェクトからモックオブジェクトに置換する
#### テストの実行環境を強化する
#### テストを並列で実行する
テストを並列で実行するには、各テストケースがお互いに独立し、実行順序に依存しない設計でなければいけません。
#### 実行するテストを絞り込む
あまり重要でないテストや時間のかかるテストは１日に１回など定期的に、それ以外のテストは常時実行するなど、  
１回で行うテストのテストケースを絞ることで、テストの実行時間を短縮できます。

### カテゴリ化テスト
カテゴリ化テストで実行するテストを絞り込むことが出来ます。
カテゴリ化テストはで`@category`でタグ付けされたテストケースから、特定のタグを含む（または含まない）テストケースのみを実行するテストのことです。
##### カテゴリ化テストの実行
1. カテゴリの種類を表すカテゴリクラスを作成する
2. テストケースまたはテストクラスにカテゴリを設定する
3. カテゴリテストを実行するためのテストスイートクラスを作成する  
  3-1. テストスイートクラスを作成する際はテストスイートクラスにする予定のクラスに`RunWith(Categories)`を設定し、`@IncludeCategory`で実施する  
       `@Category`で定義したテストカテゴリーを指定する。  
  3-2. `@SuiteClasses`で実施するテストクラスを指定する。

### スローテスト問題が発生するパターン
- テータベーステスト
- 通信処理を伴うテスト
- GUIを伴うテスト


## 【１１章：テストダブル】
### テストダブルとは？
テスト対象となるクラスやメソッドが依存するオブジェクトがユニットテストで扱いにくい場合や、ユニットテストの独立性を高めたい場合には、  
依存するオブジェクトを**代役**として置き換える方法が有効です。  
この代役となるオブジェクトはスタブやモックとして知られ、総称してテストダブルと呼びます。

### スタブ
テスト対象となるクラスやメソッドが、**依存するクラスやモジュールの代用として使用する仮のクラスやモジュールです。**  
ユニットテストにおいて、スタブを使用する目的は、**依存オブジェクトに予測可能な振る舞いをさせることです。**  
次のような場合でスタブが使用されます  
- 依存オブジェクトが予測できないふるまいをする
- 依存オブジェクトのクラスがまだ存在しない
- 依存オブジェクトの実行コストが高く、簡単に利用できない
- 依存オブジェクトが実行環境に強く依存している

#### スタブの例
- 固定値を返すスタブ
- 例外を送出するスタブ

### モック
テスト対象となるクラスやメソッドに依存している**オブジェクトのメソッドの呼び出し回数の検証など、依存オブジェクトが正しく利用されているかの検証**をするのが目的です。

### スパイ
テスト対象となるクラスやメソッドに依存している**オブジェクトに副作用を与えるメソッドのテストの場合は、標準出力やロガーへの書き込まれた内容の検証を行います。**

### Mockitoによるモックオブジェクト


## 【１２章：データベースのテスト】
### データベースに依存するユニットテスト
#### データベースを扱うソフトウェアの設計
データベースを扱うクラスのユニットテストを行う上で最も重要なことは、**クラス設計です。**  
**データベースに直接アクセスするクラスとアクセスするクラスからデータベースの情報を取得するクラスに分離させたクラス設計が好ましいです。**
そしてテストの際には、データベースに依存しない状態でユニットテストを行うべきです。

#### 三層アーキテクチャ
- データベースに直接するレイヤー：パーシステンス層
- ビジネスロジックを実装するレイヤー：サービス層
- 入力値鵜の検証や画面への表示を行うレイヤー：プレゼンテーション層

#### パーシステンス層をスタブに置き換える際のメリット・デメリット
<dl>
  <dt>メリット</dt>
    <dd>
      ・データベースに依存しないため、処理速度が速い<br>
      ・パーシステンス層のモジュールが未完成な状態でもインターフェースさえ定義していれば、サービス層の実装を進めることが出来る  
    </dd> 
  <dt>デメリット</dt>
    <dd>
      ・データベースを使っていないと発生しない問題を見逃す恐れがある。  
    </dd>
</dl>
   
#### データベースの状態とユニットテスト
<dl>
  <dt>参照系のテスト</dt>
    <dd>
      参照系処理のユニットテストでは、初期化処理で関連するデータベースのレコードをすべて削除し、前提条件となるレコードを挿入します。<br>
      テストケースごとにデータベースを初期化することで、テスト対象クラスの参照系処理は、予測可能な結果を返すことが出来ます。
    </dd> 
  <dt>更新系のテスト</dt>
    <dd>
      更新系の処理を行った後に、データベースが期待される状態になっているかを検証しなければなりません。<br>
      また、自動的に設定される「最終更新日時」、自動的に設定される「ID」など、期待値が予測できないカラムなどを除外して検証する必要があります。
    </dd>
</dl>

### ユニットテストの自動化とH2 Database
データベースを扱うユニットテストはDBサーバが起動していなければ実行できません。  
このため、ローカル環境やテスト環境でDBサーバをあらかじめ起動する必要があります。  
もし、DBサーバの起動や停止をテストの一部として組み込むことが出来れば、ユニットテストを完全に自動化することが出来ます。

#### H2 Databaseサーバの起動/停止を行うルール
### DbUnitによるDBのテスト

## 【１３章：Androidのテスト】
### GUIアプリの設計
