# JUnit 実践入門
下記には書籍「JUnit実践入門」の各章の要約を記載します。  
[参照書籍：JUnit実践入門](https://gihyo.jp/book/2012/978-4-7741-5377-3)
※【１８章～２０章】はソースコードをご参照ください
<dl>
  <dt>テスト対象のプログラム</dt>
    <dd>practice_junit/Turial-JUnit/src/</dd>
  <dt>テストクラス</dt>
    <dd>practice_junit/Turial-JUnit/test/</dd>
</dl>
  
## 【１章：JUnitチュートリアル】  
### 環境構築  
- Javaプロジェクトの作成  
- テスト対象クラスの作成  
- テストクラスの作成  
### テストコードの記述  
### テスト実行  
  
  
## 【２章：ユニットテストは何のためにテストするのか】
### ソフトウェアテストの3つの特徴
- 事前条件（テストデータ、環境など）による制約がある
- 実際のソフトウェアのふるまいを記録する
- 期待される結果との検証
### テスト技法  
- ホワイト・ブラックボックステスト  
- 同値クラスに対するテスト：ソフトウェアが同様の結果をもたらす値を同値クラスとしてグループ化し、グループが膨大である場合、代表値を選び、テストを行う
### ユニットテストの持つべき特徴
<table>
  <thead>
    <tr>
      <th>特徴</th> <th>詳細</th>
    </tr>
  </thead>
  <tr>
    <td>自動化されたテスト</td> <td>何度でも繰り返してテストを実行できることで、不具合の早期発見や安心してリファクタリングが行えるようになります.</td>
    </tr>
  <tr>
    <td>結果が一定であること</td> <td>理想的には、すべてのテストが成功している状態を維持することが望ましいです。<br>
                                    成功しないテストを放置する状況や実行ごとに成功するかが変わる状態は好ましくありません。</td>
  </tr>
  <tr>
    <td>仕様書として読めること</td> <td>仕様書を別途作成すると、認識相違がどうしても発生してしまうが、プログラムであれば認識相違が発生しにくい</td>
  <tr>
    <td>テスト対象</td> <td>そのテストの対象（クラスやオブジェクト）</td>
  </tr>
</table>
  
  
## 【３章：テスティングフレームワーク】
### JUnitによるユニットテストの記法
- `public`メソッドとする
- `org.junit.Test`アノテーションを付与する
- 戻り値を`void`とし、引数を持たない
### 可読性の高いテストコードを書くための基礎となる用語
<table>
  <thead>
    <tr>
      <th>用語</th> <th>説明</th>
    </tr>
  </thead>
  <tr>
    <td>テストケース</td> 
    <td>
      ある状況である入力をしたときにどのような結果を期待できるのかを記述したもの。<br>
      ユニットテストに限らず、ソフトウェアのテストでは次の３点が重要です。<br>
        ・テストを行う前提条件<br>
        ・テストに用いる入力値や操作<br>
        ・テストを行ったときに期待される値や操作
    </td>
  </tr>
  <tr>
    <td>テスト対象</td> <td>そのテストの対象（クラスやオブジェクト）</td>
  </tr>
  <tr>
    <td>メソッドと副作用</td> 
    <td>わかりにくいテストコードになってしまう最大の要因は、テスト対象がテストしにくい設計になっていることです<br>
        そして次のような性質を持っているメソッドはテストが行いやすいメソッドです。<br>
        ・メソッドが戻り値を持つ<br>
        ・メソッドの呼び出しの結果、副作用がない<br>
        ※副作用とはオブジェクトの内部状態（インスタンス変数など）が変更されないことである<br>
        ・同じ状態、同じパラメータで実行すれば、必ず同じ結果を返す
    </td>
  </tr>
  <tr>
    <td>４フェーズテスト</td>
    <td>ユニットテストにかかわらず、ソフトウェアのテストは次の４つのフェーズで実行されます<br>
      １．事前処理：テスト対象オブジェクトの初期化、必要な入力値、期待される結果などの準備<br>
      ２．実行テスト：対象オブジェクトに対し、テストする操作を一つだけ行います<br>
      ３．検証：テストの結果として得られた実測値が期待値と等価であるかを検証する<br>
      ４．後処理：次のテストの実行に影響がないように後処理をする
    </td>
  </tr>
  <tr>
    <td>テストフィクスチャ</td> <td>ー</td>
  </tr>
</table>

### JUnitのテストパターン
- 標準的なふるまいを検証するテスト（**正常系**）
- 例外の創出を検証するテスト（**異常系**）
- コンストラクタを検証するテスト（特殊なパターンですがインスタンスが生成されたときに、初期状態として妥当な値が設定されているかを確認します）
  
  
## 【４章：アサーション】
### アサーションメソッド
- Matcher APIで提供されているアサーションメソッド
- その他で提供されているアサーションメソッド 
### Matcher APIで提供されている様々なメソッド
### カスタムMatcherの作成手順


## 【５章：テストランナー】
### コマンドラインからのJUnitの実行
JUnitによるユニットテストをコマンドラインから実行するには、`junit.runner.JUnitCore`を使用します。

#### JUnitCoreクラスの仕組み
`JUnitCore`クラスの`main`メソッドが実行されると、`JUnitCore`クラスの起動引数で指定したテストクラスから<br>
Test<アノテーションの付いたメソッド（テストケース）を収集します<br>
**まとめると、`JUnitCore`クラスは以下の流れで動きます**
1. テストケースの収集
2. テストの実行
3. テスト結果の出力

### テストランナーとは？
ソフトウェア開発では、テストクラス単位でテストを実行するだけでは不十分で、プロジェクトの全テストケースの実行、特定のテストケースに絞った実行、<br>
特定のテストケースを除外した実行などのカスタマイズ性が求められます。<br>
そのためJUnitでは**テストランナー**という仕組みを提供しています

#### JUnitが提供するテストランナー
- Suite
  - 複数のテストクラスをまとめて実行する
  - テストスイートクラスでは、ほかのテストスイートクラスを指定することが出来ます。<br>
    パッケージごとにパッケージ内の全テストクラスを含むAllTestsを作成し、それらのテストスイートクラスをすべて含む<br>
    テストスイートクラスを作成することで、プロジェクト内の全テストケースを実行するテストスイートを作成できます。
- Enclosed
  - 構造化したテストクラスを実行する
  - Enclosedクラスをテストランナーとして指定した場合、ネストしたクラスを定義し、テストケースは各ネストしたクラスに定義します。
- Theories
  - パラメータ化したテストケースを実行する
  - パラメータ化テストとは、テストケースとテストデータを分離し、同じテストメソッドを複数のパラメータで再利用して使います。
- Categories
  - 特定カテゴリのテストクラスをまとめて実行する
  - テストケースをカテゴリー化し、実行するテストケースをフィルタリングする
    可能であれば、すべてのテストケースを実行すべきです。ですが、テスト数が増えてくると実行時間がかかりすぎてしまい、
    現実的ではないので、各テストケースにカテゴリを設定し、分割して実行します。
  
   
## 【６章：テストのコンテキスト】
### テストケースの整理方法
テストクラスに定義されたテストケースが増加してくると、テストコード自体が長く読みにくいものとなります。<br>
そしてテストコードは似たようなコードが多いため、重複が多くなりがちです。<br>
そのため重複を取り除きすぎると各テストケースの意図が不明瞭になります。<br>
なので<strong>各テストケースの独立性を保ちつつ、テストコードが読みやすく整理する必要があります。</strong><br>
以下に整理方法の代表例を記載します。

<dl>
  <dt>テストクラスの構造化</dt>
    <dd>
      一般的に、クラスベースのプログラミング言語のユニットテストでは、テスト対象となるクラスごとに対応するテストクラスを作成します。<br>
      Javaではテストクラスを慣習として</strong>「テスト対象+Test」</strong>と記述します。<br>
      多くのテストケースが定義されたテストコードの可読性が低い理由は、すべてのテストメソッドを同列に定義しているからです。<br>
      なので、<strong>テストケースが増えてきたならば、何らかの基準でグループ化し、テストクラスを構造化することが必要です。</strong>
    </dd>  
  <dt>テストケースをグループ化する</dt>
    <dd>
      テストケースをグループ化する方針としては、大きく次の二つがあります。<br>
      <strong>1. の方針は初期化処理の共通化が出来ないので、好ましくありません。2. の方針を推奨します</strong><br>
      1. テストケースで検証する操作（メソッド単位）でグループ化する<br>
      2. テストケースを共通の初期化処理を含むものでグループ化する
    </dd>
  <dt>Enclosedによるテストクラスの構造化</dt>
    <dd>
      多くあるテストケースを複数のテストクラスに分割して、整理する方法は、テストクラスの命名規則の観点であまりよろしくありません<br>
      この問題を解決するためのEnclosedによるテストクラスの構造化が使えます。<br>
      Enclosedテストランナーを利用すれば、初期化処理が共通しているテストケースをネストした複数のクラスにまとめることが出来ます。<br>
      この場合、外側のテストクラスは命名規則に従い、<strong>「テスト対象クラス名+Test」</strong>とします。<br>
      内側のそして初期化処理によってグループ化したテストクラスに関しては、<strong>「初期化状態の場合」</strong>などの初期化状態を説明するクラス名にするとよいでしょう。
    </dd>
</dl>
     
### コンテキストのパターン

<dl>
  <dt>共通のデータに着目する</dt>
    <dd>
      わかりやすい例として、データベース接続を行うクラスのユニットテストをあげます。<br>
      データベース接続を行うクラスのユニットテストでは、テストの実行前にデータベースを特定の状態に設定する必要があります<br>
      例えば、「あるテーブルが空の場合」、「10件のデータがある場合」などです。
      そのような特定の条件によってテストケースをグループ化するとよいでしょう。
    </dd>  
  <dt>共通の状態に着目する</dt>
    <dd>
      テスト対象クラスが状態を持つ場合、事前処理として行われるテスト対象オブジェクトへの操作が重要です。<br>
      事前処理の操作の結果、特定の状態となります。その状態によってテストケースをグループ化するパターンも有効です
    </dd>
  <dt>コンストラクタのテストを分ける</dt>
</dl>

### テストクラスを横断する共通処理
Enclosedテストランナーによるテストクラスの構造化を行うことで、テストクラス内の共通化処理をきれいに整理できます。<br>
しかし異なるテストクラス間で共通した処理は整理できません。このようなときは共通処理を定義した基底クラスを作成して、<br>
継承させることが多いでしょう。ですが継承はなるべく避けるべきです、なぜならば安易な継承は影響範囲の特定を困難にする恐れがあるからです。<br>
JUnitが提供する異なるテストクラス間の共通処理を抽出する機能をルールを使用すると、適切に抽出できます。


## 【７章：テストフィクスチャ】
### テストフィクスチャとは？
ソフトウェアテストでは、テスト対象となるシステムやオブジェクトだけでは成立しません。<br>
入力するデータ、テスト実行のための予備捜査、データベースなどの外部リソース、検証に必要なデータなどが必要不可欠です。<br>
これらのテストで扱うデータやテスト実行環境、オブジェクトの状態などを**フィクスチャ**と呼びます。

#### ユニットテストのフィクスチャ
- テスト対象オブジェクト
- テストの実行に必要なオブジェクト（入力値）
- テストの検証に必要なオブジェクト（検証値）
- テスト実行までに必要なテストオブジェクトの操作
- ファイルなどの外部リソース
- データベースやソケットサーバーなどの外部システム
- 依存クラスや依存外部システムのモックオブジェクト  
**多くの入力値を持ち、外部リソースにも依存するテスト対象クラスでは、特に注意してフィクスチャのセットアップを行う必要があります。**

#### フレッシュフィクスチャ
ユニットテストでは、**「フィクスチャはテストケースごとに独立し、テストの実行ごとに初期化され、終了時に解放する」**が基本です。  
この戦略は**フレッシュフィクスチャ**呼ばれます。もしフィクスチャがいくつかのテストケースごと共有されていると、<br>
テストケースの実行順序などによってフィクスチャの状態が影響を受けるかもしれません。またユニットテストを並列に実行した場合、<br>
共有されたフィクスチャが同時に複数のテストから利用されるため、あやまった入力値がテストケースに入力される恐れがあります。<br>
**Unitではテストの実行時にテストケースごとにテストクラスのインスタンスを作成し、テストメソッドを実行します。**  
**このため、テストクラスのインスタンス変数やローカル変数に保持されたテストデータは、各テストの終了時にガベージコレクタによって廃棄されます。**

#### フィクスチャとスローテスト問題
フレッシュフィクスチャは基本的なフィクスチャのセットアップパターンです。  
しかしながら、データベースを扱うテストなどでは、フィクスチャのセットアップに長い時間を要します。このような問題を**スローテスト問題**といいます。  
原因は、フィクスチャのセットアップごとに対象となるテーブルの全レコードを削除し、必要なレコードを追加するからです。  
スローテスト問題を解決するには、**テストの並列実行、共有フィクスチャ、カテゴリ化テスト**などが有効です。  
<dl>
  <dt>テストの並列実行</dt>
    <dd>マルチスレッドや複数のテスト環境で並列にテストを実行する</dd>
  <dt>共有フィクスチャ</dt>
    <dd>各テストケースで使用するフィクスチャを共有し、再利用することで、セットアップコストを抑えます</dd>
</dl>

### フィクスチャのセットアップパターン
<dl>
  <dt>インラインセットアップ</dt>
    <dd>テストメソッドごとにフィクスチャのセットアップを行います。メソッドが長くなる場合は可読性が悪くなり、何の検証を行て散るのかがわかりにくくなる。</dd>
  <dt>暗黙的セットアップ</dt>
    <dd>
      テストクラスで共通した初期化処理を、<strong>Beforeアノテーション</strong>が付加されたメソッドに抽出できます。<br>  
      そのメソッドを<strong>セットアップメソッド</strong>と呼び、各テストメソッドを実行する前に暗黙的に実行されます。<br>  
      暗黙セットアップは、Enclosedテストランナーを利用したユニットテストと相性がいいです。なぜなら共通の初期化処理を持つテストケースでグループ化するので、<br>      
      <strong>各ネスト下したクラスで、フィクスチャのセットアップのコードがセットアップメソッドに抽出され、セットアップとテストを切り分けられます。</strong>
    </dd>
  <dt>生成メソッドでのセットアップ</dt>
    <dd>
      複数のテストクラスでセットアップメソッドで共通の初期化処理を行いたい場合に使用します。<br>  
      この方法では共通した初期化処理を独立したクラスのメソッドに抽出する手法を用います。<br>
      このようにフィクスチャの生成メソッドを抽出し、フィクスチャのセットアップを行うパターンを<strong>生成メソッド</strong>と呼びます。
    </dd>
  <dt>外部リソースからのセットアップ</dt>
    <dd>
      Javaではフィクスチャのセットアップのようなデータを生成するコードはあまり読みやすくありません。<br>    
      なので外部に定義したリソースファイルにテストデータを記述し、生成メソッドなどで読み込む手法が有効です。<br>    
      リソースファイルには、YAML・XML・JSON・CSVなどがあります。  
    </dd>
</dl>


## 【８章：パラメータ化テスト】
### テストデータの選択
テストデータをどのように選択するかは、ソフトウェアテストにおいて重要な要素の一つです。なぜなら入力可能な値をすべて検証することは不可能なので  
効率よく検証できるデータを選択するしかないからです。
#### どのくらいのテストデータが必要か？
<dl>
  <dt>同値クラスによるテストデータの選択</dt>
    <dd>
      同値クラスとは、テスト対象メソッドで同じ結果を返す入力値の集合です。<br>
    </dd>
  <dt>組み合わせによるテストデータの選択</dt>
    <dd>
      各項目に対する条件分岐が存在する際に、その境界付近のテストデータ
    </dd>  
    </dd>
</dl>

### 入力値と期待値のパラメータ化
<table>
  <thead>
    <tr>
      <th>テストランナーやアノテーションの種類</th> <th>役割</th>
    </tr>
  </thead>
  <tr>
    <td>Theories（テストランナー）</td> <td>パラメータ化テストを行うクラスに付ける</td>
  </tr>
  <tr>
    <td>@Theory</td> <td>パラーメタ化テストを行うメソッドに付ける</td>
  </tr>
  <tr>
    <td>@DataPoint</td> <td>一つのテストメソッドに対して、一つのパラメータを定義する</td>
  </tr>
  <tr>
    <td>@DataPoints</td> <td>一つのテストメソッドに対して、複数のパラメータを定義する</td>
  </tr>
</table>

### 組み合わせテスト
#### Assumeによるパラメータのフィルタリング
AssumeTrueメソッドやAssumeThatメソッドを使って、特定の条件に合致するパラメータだけを検証することが出来ます。

### パラメータ化テストの問題
#### データの網羅性
テスト技法を意識しないで適当なパラメータを設定した場合、網羅性が欠如したテストになってしまう
#### パラメータに関する情報の欠如
テスト失敗時にテストメソッドに入力したパラメータの情報まで報告されないので、あるテストメソッドが失敗したのはわかるが、  
どんなパラメータを入力して、失敗したのかまではわからないので、問題の分析に時間がかかってしまいます。


## 【９章：ルール】
### ルールとは？
<strong>JUnitでは何をテストするのか（テストケース）とどう実行するのか（テストランナー）が分離されています。</strong>  
独自のテストランナーを作ることで、ユニットテストの実行をカスタマイズすることが出来ます。  
しかしながら独自のテストランナーを作るのには手間がかかります。なのでJUnitでは、プラグインのようにユニットテストを拡張できる機能が搭載されています。  
その機能を**ルール**と言います。

### ルールの仕組み
- Beforeアノテーションと同様に、テストクラスごとに拡張処理を行うことが出来る。  
- 複数ルールを宣言するとき、ルールの実行制御を行いたい場合は、RuleChainを使用します。
- ルールには単体で利用できるものとカスタムルールを作るときに基底クラスとして利用するルールの二種類があります。

### ルールの種類
<table>
  <thead>
    <tr>
      <th>ルール</th> <th>説明</th>
    </tr>
  </thead>
  <tr>
    <td>TemporaryFolder</td> <td>TemporaryFolderクラスはテストの独立性を高めるため、テストケースごとに独立して一時フォルダを作成・削除を行います。<br>
                                 ルールの拡張を行う際には<strong>TemporaryFolderを継承したサブクラスを作成し、
                                 一時フォルダの作成を行うbeforeメソッドのオーバーライドを行います。その際に親クラスのbeforeメソッドをか必ず呼び出す。</strong></td>　　　　　　　　
  </tr>
  <tr>
    <td>ExternalResource</td> <td>ExternalResourceクラスは抽象クラスであり、具体的に管理するリソースはサブクラスで定義します。<br>
                                  データベース、ソケット、組み込みサーバなどを扱うテストで重宝します。<br>
                                  ExternalResourceクラスはbeforeメソッドで外部リソースの初期化処理を定義し、<br>
                                  afterメソッドで外部リソースの解放処理を定義します。</td>
  </tr>
  <tr>
    <td>Vertify</td> <td>Vertifyクラスはテスト事後条件を検証します。ExternalResourceクラスと同様に抽象クラスです</td>
  
  <tr>
    <td>ErrorCollector</td> <td>ErrorCollectorクラスはアサーションの失敗やエラーが発生した場合でも、テストを継続して実行することのできる<br>
                                仕組みを提供します。テストが失敗したという情報は、ErrorCollectorオブジェクトに蓄積され、<br>
                                テストが失敗によって中断されず、すべての項目に関する情報を知ることが出来ます。</td>
  </tr>
  <tr>
    <td>ExceptedException</td> <td>送出された例外を詳細に検証するためのルールです。</td>
  </tr>
  <tr>
    <td>Timeout</td> <td>テストケースのタイムアウトを設定するためのルールです。<br>
                         テストクラス内のすべてのテストメソッドにタイムアウトが設定されます。</td>
  </tr>
  <tr>
    <td>TestWatcher</td> <td>テスト実行時の様々なタイミングで追加の処理を実行できます。<br>
                             TestWatcherクラスは抽象クラスであり、サブクラスで必要あメソッドをオーバーライドして利用します。<br>
                             よく使われる例が、各フェーズでログを出力する場合です。</td>
  </tr>
  <tr>
    <td>TestName</td> <td>テストメソッド内で実行中のテストメソッド名を取得するためのルールです。<br>
                          TestNameオブジェクトからテストメソッド名を取得します。<br>
                          JUnitにおけるテストメソッド名はテストケースの概要を表しているので、有益な情報となるのでこのルールは重宝されます。</td>
  </tr>
</table>

### RuleChainによるルールの連鎖
ルールをテストクラスに定義するだけでは、順序の制御を行うことが出来ないので、`RuleChain`クラスにてルールをchainさせて記述し、実行順序の制御を行います。


## 【１０章：カテゴリ化テスト】
### スローテスト問題の対策
#### テストの実行時間を短くするための方法
- テストデータの共有化
- リアルオブジェクトからモックオブジェクトに置換する
#### テストの実行環境を強化する
#### テストを並列で実行する
テストを並列で実行するには、各テストケースがお互いに独立し、実行順序に依存しない設計でなければいけません。
#### 実行するテストを絞り込む
あまり重要でないテストや時間のかかるテストは１日に１回など定期的に、それ以外のテストは常時実行するなど、  
１回で行うテストのテストケースを絞ることで、テストの実行時間を短縮できます。

### カテゴリ化テスト
カテゴリ化テストで実行するテストを絞り込むことが出来ます。
カテゴリ化テストはで`@category`でタグ付けされたテストケースから、特定のタグを含む（または含まない）テストケースのみを実行するテストのことです。
##### カテゴリ化テストの実行
1. カテゴリの種類を表すカテゴリクラスを作成する
2. テストケースまたはテストクラスにカテゴリを設定する
3. カテゴリテストを実行するためのテストスイートクラスを作成する  
  3-1. テストスイートクラスを作成する際はテストスイートクラスにする予定のクラスに`RunWith(Categories)`を設定し、`@IncludeCategory`で実施する  
       `@Category`で定義したテストカテゴリーを指定する。  
  3-2. `@SuiteClasses`で実施するテストクラスを指定する。

### スローテスト問題が発生するパターン
- テータベーステスト
- 通信処理を伴うテスト
- GUIを伴うテスト


## 【１１章：テストダブル】
### テストダブルとは？
テスト対象となるクラスやメソッドが依存するオブジェクトがユニットテストで扱いにくい場合や、ユニットテストの独立性を高めたい場合には、  
依存するオブジェクトを**代役**として置き換える方法が有効です。  
この代役となるオブジェクトはスタブやモックとして知られ、総称してテストダブルと呼びます。

### スタブ
テスト対象となるクラスやメソッドが、**依存するクラスやモジュールの代用として使用する仮のクラスやモジュールです。**  
ユニットテストにおいて、スタブを使用する目的は、**依存オブジェクトに予測可能な振る舞いをさせることです。**  
次のような場合でスタブが使用されます  
- 依存オブジェクトが予測できないふるまいをする
- 依存オブジェクトのクラスがまだ存在しない
- 依存オブジェクトの実行コストが高く、簡単に利用できない
- 依存オブジェクトが実行環境に強く依存している

#### スタブの例
- 固定値を返すスタブ
- 例外を送出するスタブ

### モック
テスト対象となるクラスやメソッドに依存している**オブジェクトのメソッドの呼び出し回数の検証など、依存オブジェクトが正しく利用されているかの検証**をするのが目的です。

### スパイ
テスト対象となるクラスやメソッドに依存している**オブジェクトに副作用を与えるメソッドのテストの場合は、標準出力やロガーへの書き込まれた内容の検証を行います。**

### Mockitoによるモックオブジェクト


## 【１２章：データベースのテスト】
### データベースに依存するユニットテスト
#### データベースを扱うソフトウェアの設計
データベースを扱うクラスのユニットテストを行う上で最も重要なことは、**クラス設計です。**  
**データベースに直接アクセスするクラスとアクセスするクラスからデータベースの情報を取得するクラスに分離させたクラス設計が好ましいです。**
そしてテストの際には、データベースに依存しない状態でユニットテストを行うべきです。

#### 三層アーキテクチャ
- データベースに直接するレイヤー：パーシステンス層
- ビジネスロジックを実装するレイヤー：サービス層
- 入力値鵜の検証や画面への表示を行うレイヤー：プレゼンテーション層

#### パーシステンス層をスタブに置き換える際のメリット・デメリット
<dl>
  <dt>メリット</dt>
    <dd>
      ・データベースに依存しないため、処理速度が速い<br>
      ・パーシステンス層のモジュールが未完成な状態でもインターフェースさえ定義していれば、サービス層の実装を進めることが出来る  
    </dd> 
  <dt>デメリット</dt>
    <dd>
      ・データベースを使っていないと発生しない問題を見逃す恐れがある。  
    </dd>
</dl>
   
#### データベースの状態とユニットテスト
<dl>
  <dt>参照系のテスト</dt>
    <dd>
      参照系処理のユニットテストでは、初期化処理で関連するデータベースのレコードをすべて削除し、前提条件となるレコードを挿入します。<br>
      テストケースごとにデータベースを初期化することで、テスト対象クラスの参照系処理は、予測可能な結果を返すことが出来ます。
    </dd> 
  <dt>更新系のテスト</dt>
    <dd>
      更新系の処理を行った後に、データベースが期待される状態になっているかを検証しなければなりません。<br>
      また、自動的に設定される「最終更新日時」、自動的に設定される「ID」など、期待値が予測できないカラムなどを除外して検証する必要があります。
    </dd>
</dl>

### ユニットテストの自動化とH2 Database
データベースを扱うユニットテストはDBサーバが起動していなければ実行できません。  
このため、ローカル環境やテスト環境でDBサーバをあらかじめ起動する必要があります。  
もし、DBサーバの起動や停止をテストの一部として組み込むことが出来れば、ユニットテストを完全に自動化することが出来ます。

#### H2 Databaseサーバの起動/停止を行うルール
### DbUnitによるDBのテスト


## 【１３章：Androidのテスト】
### GUIアプリの設計
#### GUIアプリのスレッドモデル
GUIアプリでは画面描画とイベント処理をシングルスレッドモデルで行うことになっています。なぜならバックグラウンドスレッドでGUIフレームワークで実装することは困難だからです。  
したがってイベントの処理に時間がかかると、GUIの再描画を行うことが出来ません。  
そこでイベントの処理に時間がかかる場合は、バックグラウンドスレッドを作って実行させます。しかしバックグラウンドスレッドでGUIの更新を行うとシングルスレッドモデルに違反します。  
なのでバックグラウンドスレッドでの処理の後に、GUIを更新したい場合はシングルスレッドを利用してGUI更新を行います。

### MVCパターンによるAndroidアプリの作成
1. Androidプロジェクトの作成  
2. エミュレーターの起動  
3. レイアウトを作成する  
4. コンポーネントがイベントハンドラをバインドさせる  
5. モデル用のプロジェクトの作成  
6. モデルの定義  
7. モデルのスタブ実装（ユーザー認証機能のスタブ）  

#### 独立したモデルプロジェクトのメリット
- モデルプロジェクトからAndroidプロジェクトを参照できないため、モデルに含まれるクラスはビューとコントロールから独立する。  
  したがって影響範囲が狭まり、エラー特定もしやすくなる。  
- Android SDKに依存しないため、使用できるライブラリが増える

### モデルのテスト
### ビューとコントローラーのテスト
### GUIアプリのテストにおける注意点


## 【１４章：コードカバレッジ】
### コードカバレッジとは？
テスト実行時にプロダクションコードが実行された割合を表したもの。
#### カバレッジの基準
カバレッジは、どのような基準で測定するかによって異なる値となります。

<table>
  <thead>
    <tr>
      <th>基準</th> <th>説明</th>
    </tr>
  </thead>
  <tr>
    <td>C0（命令網羅）</td> <td>プログラム中に定義された「命令」について１回以上実行されたかを判定する基準</td>　　　　　　　　
  </tr>
  <tr>
    <td>C1（分岐網羅）</td> <td>プログラム中の各分岐について１回以上実行されたかを判定する基準<br>
                                if文やswitch文などの条件分岐、try-catch構文による例外処理などが相当します。</td>
  </tr>
  <tr>
    <td>C2（条件網羅）</td> <td>プログラムの判定条件に着目し、すべての真偽条件の組み合わせが実行されているかどうかを判定する基準です。<br>
                                複数の条件の組み合わせによる条件分岐において、すべての真偽値の組み合わせが実行されたかを測定します。</td>
  </tr>
</table>

#### カバレッジ測定の効果
- カバレッジの値の値が極端に低ければ、ユニットテストの不足を予測することが出来る。
- ユニットテストを追加したにもかかわらず、カバレッジに変化がなければ、何らかの理由で意図した処理が実行されていない恐れがある。

### カバレッジツールを利用することで得られる恩恵
<dl>
  <dt>ユニットテストの漏れを監視する</dt>
    <dd>
      カバレッジを定期的に測定し、プロジェクトで定めている基準値を下回っていないかを測ります。<br>
      ただし、基準値下回った場合も、カバレッジが低くなった原因を分析しましょう。例えば、効果的なリファクタリングが行われ、重複コードが減った結果、<br>
      カバレッジが減った場合もあります。一様にユニットテストが漏れたからカバレッジが減ったと決めつけるべきではありません。
    </dd>
  <dt>テストケースの問題を検知する</dt>
    <dd>
      重要な処理や分岐が実行されていなかったならば、テストケースに何らかの不備がある、またはテストケース自体が漏れていると考えられます。<br>
      逆に十分なテストデータがあったならば、その処理は不要であるということになります。
    </dd>  
  <dt>コードの実行をトレースできる</dt>
    <dd>
      実行された部分とされなかった部分で区別して、グラフィカルに見ることができるので、ピンポイントでブレイクポイントを打って、デバッグを実行できます。
    </dd>  
</dl>


## 継続的なテスト
### 継続的なテスト
#### 開発チームへの素早いフィードバック
<dl>
  <dt>早期からテストする</dt>
    <dd>
      従来、テストはソフトウェアが完成してから行うものと考えられてきました。ですが、ソフトウェアを構成する最小部品のクラスなどを対象とするユニットテストは、<br>
      開発の早い段階で実施できます。また、ユニットテストは対象となるクラスの内部実装を考慮したテストなので、対象クラスの実装と同時にテストの作成を行うと、<br>
      効率よく開発が出来ます。そしてユニットテストが実施されているテストは安心して利用できます。
    </dd>
  <dt>自動的にテストする</dt>
    <dd>
      GUIのツールやコマンドラインからプログラムとして自動的に実行できなければなりません。
    </dd>  
  <dt>繰り返しテストできる</dt>
    <dd>
      ソフトウェアは多くのクラスが互いに依存して構築されます。なのでクラスを編集したことによる影響は各クラスに伝播します。<br>
      なので動いているコードは極力いじらないで制約を課せられることが多くあります。<br>
      しかしユニットテストを繰り返し実行できれば、コードの修正がしやすくなります。
    </dd> 
</dl>

#### 継続的なテストとは？
早い段階でテストを繰り返し実行するプラクティスです。  
継続的なテストを実践することで、修正や追加による影響が開発チームに素早くフィードバックされます。
     
#### 続的なテストをリファクタリング
リファクタリングを行うには、ユニットテストが必ず必要です。ユニットテストなしでリファクタリングを行うと、プロダクトコードの修正による影響がすぐに特定できないからです。  
バージョン管理システムにプロダクトコードの変更を登録すれば、自動的にすべてのユニットテストが実行されるので、変更によって問題が発生してもすぐに対応できます。

### Mavenによるビルドプロセスの自動化
#### [Mavenを使ってできること](https://camp.trainocate.co.jp/magazine/about-maven/)
<dl>
  <dt>ライブラリの管理</dt>
    <dd>
      XMLに必要なライブラリの情報を記述することで、「そのプロジェクトに必要なライブラリ」を一元管理してくれます。<br>
      Mavenは依存性を管理する機能も備わっている
    </dd>
  <dt>ライブラリの自動インストール</dt>
    <dd>
      依存関係を持つライブラリを一括でダウンロードすることが出来ます。
    </dd>  
  <dt>ビルド</dt>
    <dd>
      <stron>インストール、Javaファイルのコンパイル、自動テスト、パッケージの作成</trong>を一括で実行します。
    </dd> 
</dl>

### [Jenkinsでの継続的インテグレーション](https://ics.media/entry/tutorial-jenkins/)
#### Jenkinsの設定 ～Githubからの通リを受け取る設定～
1. Jenkinsプラグインのインストール  
2. Githubから最新のファイルを取得するジョブを作成
3. 通知を受け取るジョブを作成

#### Githubの設定 ～GithubからJenkinsへの通知
GithubからJenkinsへの通知は、GithubのWebhooksという機能を利用して行います。  
WebhoooksとはGithubのリポジトリに変化があった際に、Jenkinsのジョブを実行するための実行URLをたたく機能です。  
（例：実行URL）http://[Jenkinsの動作するドメイン]/job/[ジョブの名前]/buildWithParameters


## 【１６章：テスト駆動開発】
### テスト駆動開発とは？
ユニットテストをプロダクトコードよりも先に記述することを原則とした開発手法です。  

### テスト駆動開発のサイクル
1. 設計する
2. テストコードを書く（テスト失敗）
3. プロダクトコードを書く（テスト成功）
4. リファクタリングをする

#### 設計をする
クラスやメソッドの引数や返り値、副作用を設計し、テストすべきことがわかることを目標にしています。

#### テストコードを書く
１回のサイクルで作成するテストケースは原則として１ケースです。  
テスト対象のテストメソッドを作成する場合は、メソッドの名前を「テストメソッドの仕様（引数と返り値） + 例外」を考えて記述します。

#### プロダクトコードを書く
テストコードが作成できた時点では、プロダクションコードを作成していないので、この時点ではテストは必ず失敗します。  
そしてプロダクトコードを書く際は、テストが成功させることを目標に作成します。例外処理などの異常系の処理はこの時点では実装しなくてもよいです。  
最速でテストを成功させるため、プロダクトコードは仮実装で行います。

#### リファクタリングを行う

#### 三角測量
サイクルを重ねるごとにテストケースを増やしていき、テストデータはテスト技法に即したテストデータを設定します。  
プロダクトコードは追加されたテストケースにも対応できるように編集します。

### テスト駆動開発の目的
<dl>
  <dt>ステップバイステップ</dt>
    <dd>たくさんのことを一気にやろうとしてはいけません。</dd>
  <dt>自分が最初のユーザ</dt>
    <dd>テストコードを先に書くため、対象となるクラスやメソッドを利用します。その時点でテスト対象となるクラスやメソッドが使いにくいのであれば、修正することが出来ます</dd>  
  <dt>動作するきれいなコード</dt>
  <dt>動作結果に関する素早いフィードバック</dt> 
  <dt>メンテナンスされたドキュメント</dt>
    <dd>テストコードはメンテナンスされ動作するドキュメントでありサンプルコードです。</dd>  
</dl>


## 【１７章：振舞駆動開発】
### 受け入れテストとは？
本書で扱ってきたユニットテストの対象はクラスやメソッドであり、これらはソフトウェアを構成する最小単位の部品です。  
なので、最終的には関連するクラスやメソッドが結合していき、エンドトゥエンドで検証する必要があります。
